if (hasProperty('conf')) {
    System.err.println "Using configuration data from ${conf}"
    File confFile = new File(conf)
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${conf} found.")
    }
    apply from: conf

} else {
    File confFile = new File("${rootProject.rootDir}/conf.gradle")
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${conf} found.")
    }
    System.err.println "Using conf.gradle for configuration"
    apply from: "${rootProject.rootDir}/conf.gradle"
}


buildscript {
  repositories {
    maven {
      url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
  }
  dependencies {
    classpath group: 'edu.holycross.shot', name: 'hocuspocus', version : hocuspocusVersion
    classpath group: 'edu.holycross.shot', name: 'safecsv', version: safecsvVersion
    classpath group: 'org.homermultitext', name : 'citemgr' , version: citemgrVersion
  }
}

import org.homermultitext.citemanager.DseManager
import edu.holycross.shot.hocuspocus.Corpus
import edu.holycross.shot.safecsv.SafeCsvReader
import edu.harvard.chs.cite.CiteUrn
import edu.harvard.chs.cite.CtsUrn


task setUpVisualInventory(type: Copy) {
  description = "Copy template files for visual inventory to build area."
  from "visualinventory"
  into "${buildDir}/visualinventory"
}


DseManager initDse (String folioToImage, String textToImage ) {
  DseManager dse = new DseManager()
  folioToImage.split(/,/).each { idx ->
    if (dse.tbsImageIndexFiles) {
      dse.tbsImageIndexFiles.add(new File(idx))
    } else {
      dse.tbsImageIndexFiles = [new File(idx)]
    }
  }
  dse.tbsImageIndexFiles.add(new File("${rootProject.rootDir}/archivemg/build/scholia/scholiaToTbs.csv"))

  textToImage.split(/,/).each { idx ->
    if (dse.textImageIndexFiles) {
      dse.textImageIndexFiles.add(new File(idx))
    } else {
      dse.textImageIndexFiles = [new File(idx)]
    }
  }
  dse.textImageIndexFiles.add(new File ("${rootProject.rootDir}/archivemg/build/scholia/scholiaToImage.csv"))

  return dse
}

/* DSE analysis for a physical surface, or a range
 * of physical surfaces, identified by URN value
 * of the project property "folio".
 */
task dse(dependsOn : [setUpVisualInventory, ":archivemgr:prepareArchive"]) {
  description = "Does DSE analysis of material for one folio"
}
dse.doLast {
  println "Validating DSE structure for folio " + folio


  CiteUrn urn
  try {
    urn  = new CiteUrn(folio)
  } catch (Exception e) {
    System.err.println "Unable to make urn for ${folio}"
    throw e
  }

  /*
  def scorecard = []
  def reptDetails = [:]
  Integer totalGood = 0
  */


  println "DSE configuration:"
  println "\tfolioToImage index: " + folioToImage
  println "\ttextToImage index: " + textToImage

  DseManager dse = initDse(folioToImage,textToImage)
  println "Text img index files: " + dse.textImageIndexFiles

  /*
  System.err.println "Found ${dse.textNodesForSurface(urn).size()} text nodes, breaking down as follows: "
  dse.textTbsIndexFiles.each { f ->
    System.err.println "\tin the index ${f}, " + dse.textNodesForSurface(urn, f).size() + " nodes"
  }
  System.err.println "Using default image " + dse.imageForTbs(urn)  + ", found ${dse.textNodesForImage(dse.imageForTbs(urn)).size()} text nodes"
*/

/*

    def rept = dse.dseReport(urn)

    reptDetails[urn.toString()] = rept

    String xml =  dse.getVisualInventoryXml(urn)
    String fName = "${buildDir}/visualinventory/${urn.getCollection()}_${urn.getObjectId()}.xml"
    File visinv = new File(fName)
    visinv.setText(xml,"UTF-8")
    boolean passfail = dse.verifyTbs(urn)
    if (passfail) { totalGood++ }
    def score = [urn,passfail]
    scorecard.add(score)

  }



  StreamingMarkupBuilder smb = new StreamingMarkupBuilder()
  smb.encoding = "UTF-8"




  def doc = smb.bind {
    mkp.xmlDeclaration()
    html {
      head () {
	meta(charset: "UTF-8")
	title("DSE validation for ${urn.getCollection()}, pages ${urn.getObjectId()}")
      }
      body {
	h1("DSE validation for ${urn.getCollection()}, pages ${urn.getObjectId()}")
	h2("Summary")
	p {
	  mkp.yield "Totals:  "
	  strong "${scorecard.size()}"
	  mkp.yield " pages examined, "
	  strong "${totalGood}"
	  mkp.yield " pages pass DSE validation."
	}
	h2("Page-by-page record")
	p {
	  mkp.yield "Visual inventories for individual pages are in the "
	  code("visualinventory")
	  mkp.yield "subdirectory."
	}
	table {
	  tr {
	    th("Page")
	    th("Summary")
	    th("See visual inventory")
	    th("Default image")
	    th("Same texts indexed to image and surface")
	    th("Notes")
	  }
	  scorecard.each { pair ->
	    CiteUrn pg = pair[0]
	    String defaultImg = "none found"

	    String bgcolor = "#ffb0b0"
	    String summary = "Failed one or more tests."
	    if (pair[1]) {
	      bgcolor = "#afa"
	      summary = "Passed all tests."
	    }

	    tr {
	      td("${pg}")
	      td(style: "padding: 0.2em; background-color: ${bgcolor};",summary)
	      td {
		a (href: "visualinventory/${pg.getCollection()}_${pg.getObjectId()}.xml", "inventory for ${pg.getObjectId()}")
	      }

	      def details = reptDetails[pg.toString()]
	      bgcolor = "#ffb0b0"


	      def imgRept = details[0]

	      if (imgRept.success) {
		bgcolor = "#afa"
		defaultImg = imgRept.summary
	      }
	      td(style: "padding: 0.2em; background-color: ${bgcolor};",defaultImg)


	      def mappingRept = details[1]


	      bgcolor = "#ffb0b0"
	      if (mappingRept.success) {
		bgcolor = "#afa"
	      }
	      td(style: "padding: 0.2em; background-color: ${bgcolor};",mappingRept.summary)


	      def txtCheck = dse.textNodesForSurface(pg)
	      if (txtCheck.size() == 0) {
		td(style: "padding: 0.2em; background-color: #ffffcc;", "Caution: no text units found for this page.")
	      } else {
		// check for no Iliad text
		String iliad = "urn:cts:greekLit:tlg0012.tlg001.msA:"
		def iMapKeys = dse.imageMapsByText(defaultImg).keySet()
		if (! iMapKeys.contains(iliad)) {
		  td(style: "padding: 0.2em; background-color: #ffffcc;") {
		    strong("Caution")
		    mkp.yield ": no "
		    em("Iliad")
		    mkp.yield (" text found for this page.")
		  }
		} else {
		  td("")
		}
	      }
	    }
	  }
	}
      }
    }
  }
  File totals = new File("${buildDir}/dse-validation-${urn.getObjectId()}.html")
  totals.setText(doc.toString(), "UTF-8")
*/
  println "\n===>"
  println "1. Results of DSE validation are in ${buildDir}/dse-validation-${urn.getObjectId()}.html"
  println "<==="
}






/*
task tabulate(dependsOn: [dse, tabsimple]) {
  description = "Full HMT tabulation, depending on DSE anlaysis, and writing tabulated form of all inventoried texts in ${buildDir}/tabulated."
}



task textsForSurface(dependsOn: tabulate) {
  description="Selects tabulated text data for requested text-bearing surface."

  //inputs.dir "${buildDir}/tabulated"
  //outputs.dir "${buildDir}/surfaceTabs"
}

textsForSurface.doLast {
  // output directory:
  File tabsDir = new File(buildDir, "tabulated")

  // input files:
  File archiveDir = new File(textArchive)
  File tiFile = new File(textInventory)
  File textConf = new File(textConfig)
  File schemaFile = new File(invSchema)
  // Get a hocuspocus corpus for text repository:
  Corpus corpus = new Corpus(tiFile, textConf, archiveDir) //, schemaFile)

  // configure a DseManager with
  // files identified by configuration values
  DseManager dse = new DseManager()

  // array of file names with folio-image indexing
  folioToImage.split(/,/).each { idx ->
    if (dse.tbsImageIndexFiles) {
      dse.tbsImageIndexFiles.add(new File(idx))
    } else {
      dse.tbsImageIndexFiles = [new File(idx)]
    }
  }

  // array of file names with text-image indexing
  textToImage.split(/,/).each { idx ->
    if (dse.textImageIndexFiles) {
      dse.textImageIndexFiles.add(new File(idx))
    } else {
      dse.textImageIndexFiles = [new File(idx)]
    }
  }
  dse.textImageIndexFiles.add(new File(buildDir, "scholiaToImage.csv"))


  // array of file names with text-folio indexing
  textToFolio.split(/,/).each { idx ->
    if (dse.textTbsIndexFiles) {
      dse.textTbsIndexFiles.add(new File(idx))
    } else {
      dse.textTbsIndexFiles = [new File(idx)]
    }
  }
  dse.textTbsIndexFiles.add(new File (buildDir, "scholiaToTbs.csv"))


  System.err.println "Get tabs for ${folio} from files in ${tabsDir}"
  // get relevant tabular data, and tokenize it:
  //dse.debug = 10
  ArrayList tabData = dse.tabDataForSurface(folio, corpus, tabsDir)
  System.err.println ("Results in tabData " + tabData)

  if (dse.debug > 5) {
    System.err.println "dse.tabDataForSurface yields " + tabData.size() + " entries, from "
    System.err.println "tabsDir: " + tabsDir + " for folio " + folio
    System.err.println "corpus built from " + textArchive + " with inventory " + textInventory
  }

  File outputDir = new File(buildDir, "surfaceTabs")
  if (! outputDir.exists()) {
    outputDir.mkdir()
  }

  File tabDataFile = new File(outputDir, "tab.txt")
  tabData.each {
    tabDataFile.append(it + "\n", "UTF-8")
  }

  if (dse.debug > 0) {
    println "textsForSurface settings:"
    println "\tcorpus built from " + textArchive + " with inventory " + textInventory
    println "\ttabsDir was " + tabsDir
  }
}
*/



/*
def range = urn.getObjectId().split(/-/)
if (range.size() == 2) {
System.err.println "Pages ranges are not currently suppored.  Please validate one page at a time."



String startUrn = "urn:cite:${urn.getNs()}:${urn.getCollection()}.${range[0]}"
String endUrn = "urn:cite:${urn.getNs()}:${urn.getCollection()}.${range[1]}"
File venAseq = new File(codexModel)
println "Running DSE from folio " +startUrn + " to " + endUrn
boolean inSeq = false
Integer lineCount = 0
venAseq.eachLine { l ->
  if (lineCount > 0) {
def cols = l.split(/,/)
String currUrnStr = cols[1]
CiteUrn currUrn
try {
currUrn = new CiteUrn(currUrnStr)
} catch (Exception e) {
throw new Exception("Could not make URN from ${currUrnStr}")
}
if (cols[1] == startUrn) {
inSeq = true
}
if (inSeq)  {
def rept = dse.dseReport(currUrn)
reptDetails[currUrn.toString()] = rept
String xml =  dse.getVisualInventoryXml(currUrn)
String fName = "${buildDir}/visualinventory/${urn.getCollection()}_${currUrn.getObjectId()}.xml"
File visinv = new File(fName)
visinv.setText(xml,"UTF-8")
boolean passfail = dse.verifyTbs(currUrn)
if (passfail) { totalGood++ }
def score = [currUrn,passfail]
scorecard.add(score)
}

if (cols[1] == endUrn) {
inSeq = false
}
  }
  lineCount++;
}
*/
